Оптимізація запиту до 'study_performance'.
https://www.kaggle.com/datasets/bhavikjikadara/student-study-performance

Мета запиту: 
Потрібно отримати середні бали з математики, читання і письма по кожній комбінації статі (gender)
і етнічної групи (race_ethnicity) серед учнів, які:

1. Закінчили курс підготовки (test_preparation_course = 'completed').
2. Мають рівень освіти батьків в топ-2 за частотою появи (parental_level_of_education).
3. Для яких середній бал з математики більший за середній бал по всій таблиці.

Було згенеровано штучним інтелектом складний не отптимізований запит.

Основні проблеми в запиті (original query):
1. Повторні повні сканування таблиці study_performance через підзапит у JOIN.
При кожному виконанні основного запиту JOIN має виконувати цей підзапит і робити повний скан таблиці. А також підзапит у HAVING.
2. Використання JOIN із підзапитом для фільтрації за двома найбільш популярними рівнями освіти це дуже повільно.
Краще використовувати CTE щоб один раз обчислити топ-2 рівні освіти і фільтрувати по ним.
3. Відсутність індексів.
Запит фільтрує по test_preparation_course = 'completed' і по parental_level_of_education.
Тобто MySQL виконує повний скан таблиці , що повільно при великому обсязі даних.
4. Використання HAVING із агрегатом без попередньої фільтрації
HAVING AVG(t1.math_score) > (SELECT AVG(math_score) FROM study_performance)
Спочатку групує всі записи, потім фільтрує групи.
Якщо обчислити середній бал один раз та застосувати фільтр раніше, можна уникнути додаткових витрат.

Після оптимізації запит було покращено.(step1_refactor)
Що змінено:
1. Використання CTE.
TopParentalEducation — обчислює топ-2 найпопулярніших значення parental_level_of_education один раз.
OverallAvgMath — обчислює загальний середній бал з математики один раз.
FilteredStudents — відбирає записи з таблиці study_performance, де:
test_preparation_course = 'completed'
parental_level_of_education входить до топ-2 (з TopParentalEducation).
Це замінює повторні підзапити в JOIN і в HAVING, які у початковому варіанті виконувалися кожного разу.

2. Відбір по test_preparation_course і топ-2 рівнях освіти робиться до агрегації (FilteredStudents).
Таким чином, основний запит працює вже з відфільтрованим набором даних, а не з усією таблицею.

3. Використання IN замість JOIN.
Це знижує складність оптимізатора і може покращити продуктивність.

4. Обчислення середнього балу з математики окремо,а не повторює цей підрахунок для кожної групи (як у HAVING в початковому запиті).
Це виключає зайві повні сканування таблиці.

Індексація

1. CREATE INDEX idx_test_prep ON study_performance(test_preparation_course);
Пришвидшує фільтрацію рядків за колонкою test_preparation_course.
У запиті часто використовується умова WHERE test_preparation_course = 'completed'.
Індекс дозволяє швидко знаходити всі записи, де курс підготовки завершено, без повного сканування таблиці.

2. CREATE INDEX idx_parental_education ON study_performance(parental_level_of_education);
Пришвидшує пошук та фільтрацію за parental_level_of_education.
Запит фільтрує записи, вибираючи лише тих, у кого рівень освіти батьків входить у топ-2.
Індекс допомагає швидко зіставити записи з потрібними рівнями освіти, зменшуючи час пошуку.

3. CREATE INDEX idx_gender_race ON study_performance(gender, race_ethnicity);
Оптимізує операції GROUP BY gender, race_ethnicity та дозволяє швидко групувати.
У запиті групування відбувається саме за цими двома полями.

4. CREATE INDEX idx_math_score ON study_performance(math_score);
Покращує швидкість обчислення  функції AVG(math_score) або фільтрації по math_score (якщо потрібна).
У запиті є обчислення середнього балу з математики, а також умова в HAVING з порівнянням середнього.


Отже, в результаті оптимізації запит став більш продуктивним, зменшив навантаження на базу даних та 
став легшим для розуміння .


